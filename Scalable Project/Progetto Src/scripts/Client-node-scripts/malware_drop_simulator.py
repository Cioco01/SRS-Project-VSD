# scripts/malware_drop_simulator.py
import requests
import json
from datetime import datetime
import os
import time

# Funzione per ottenere l'IP locale (copiata per self-containment)
def get_local_ip():
    try:
        response = requests.get("http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip",
                                headers={"Metadata-Flavor": "Google"}, timeout=0.5)
        if response.status_code == 200:
            return response.text
    except requests.exceptions.RequestException:
        pass
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    except Exception:
        ip = "127.0.0.1"
    finally:
        s.close()
    return ip

LOCAL_IP = get_local_ip()

def simulate_malware_drop(c2_domains, file_paths, simulated_size_kb, log_file="/var/log/malicious_traffic.log"):
    """
    Simula il download di un "malware" da domini C2 simulati.
    Non scarica un file reale, ma simula il traffico HTTP/S.
    """
    print(f"[Malware Drop] Starting malware drop simulation...")

    os.makedirs(os.path.dirname(log_file), exist_ok=True)

    for domain in c2_domains:
        for path in file_paths:
            url = f"http://{domain}{path}" # Potrebbe essere anche HTTPS
            timestamp = datetime.now().isoformat()
            
            try:
                # Simula una richiesta per un file binario
                # stream=True per simulare il download di un file di grandi dimensioni
                # Puoi aggiungere un timeout piÃ¹ lungo se necessario
                response = requests.get(url, stream=True, timeout=10)
                
                status_code = response.status_code
                content_length = int(response.headers.get("Content-Length", 0)) # Dimensione reale se disponibile
                
                # Consuma il contenuto per simulare il download effettivo
                downloaded_bytes = 0
                for chunk in response.iter_content(chunk_size=simulated_size_kb * 1024):
                    downloaded_bytes += len(chunk)
                    # Non fare nulla con il chunk, solo simulare il consumo
                    if downloaded_bytes >= simulated_size_kb * 1024:
                        break # Simula solo fino alla dimensione desiderata

                log_entry = {
                    "timestamp": timestamp,
                    "event_type": "Malicious_MalwareDrop",
                    "source_ip": LOCAL_IP,
                    "destination_url": url,
                    "destination_ip": response.raw._connection.sock.getpeername()[0] if response.raw._connection.sock else "UNKNOWN", # IP del server C2
                    "status_code": status_code,
                    "simulated_size_kb": simulated_size_kb,
                    "download_status": "Success",
                    "message": f"Simulated download of {simulated_size_kb}KB from {url}. Status: {status_code}"
                }
                print(f"[Malware Drop] Simulated download from {url}. Status: {status_code}")

            except requests.exceptions.ConnectionError as e:
                log_entry = {
                    "timestamp": timestamp,
                    "event_type": "Malicious_MalwareDrop_Failed",
                    "source_ip": LOCAL_IP,
                    "destination_url": url,
                    "simulated_size_kb": simulated_size_kb,
                    "download_status": "Failed_Connection",
                    "error": str(e),
                    "message": f"Failed to connect to {url} (ConnectionError): {e}"
                }
                print(f"[Malware Drop] Failed to connect to {url}: {e}")
            except requests.exceptions.Timeout as e:
                log_entry = {
                    "timestamp": timestamp,
                    "event_type": "Malicious_MalwareDrop_Failed",
                    "source_ip": LOCAL_IP,
                    "destination_url": url,
                    "simulated_size_kb": simulated_size_kb,
                    "download_status": "Failed_Timeout",
                    "error": str(e),
                    "message": f"Request to {url} timed out: {e}"
                }
                print(f"[Malware Drop] Request to {url} timed out: {e}")
            except Exception as e:
                log_entry = {
                    "timestamp": timestamp,
                    "event_type": "Malicious_MalwareDrop_Failed",
                    "source_ip": LOCAL_IP,
                    "destination_url": url,
                    "simulated_size_kb": simulated_size_kb,
                    "download_status": "Failed_Other",
                    "error": str(e),
                    "message": f"An unexpected error occurred during malware drop simulation for {url}: {e}"
                }
                print(f"[Malware Drop] An unexpected error occurred for {url}: {e}")

            with open(log_file, "a") as f:
                f.write(json.dumps(log_entry) + "\n")
            
            time.sleep(2) # Pausa tra i tentativi di download

if __name__ == '__main__':
    # Esempio di utilizzo standalone per test locali
    simulate_malware_drop(
        c2_domains=["example.com"], # Userai IP fittizi o domini che risolvono a nulla per il test
        file_paths=["/evil.exe"],
        simulated_size_kb=500
    )